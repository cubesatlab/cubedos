\chapter{Requirements}
\label{chapt-requirements}

\section{Introduction}

Merc is a tool that comes open source with CubedOS, a modular application framework for small
satellites. Merc is written in Scala and takes as user input a subset of the specified formal
language of XDR (with some modification) and produces provable SPARK 2014 as output (*.ads and
concomitant *.adb). The user may then manually insert the code into their project and test it.
The SPARK 2014 code generated by Merc shall be the procedures and functions used to encode
and decode CubedOS messages for inter-modular communications—repetitive, boilerplate-like code.

\section{Key Features}

\begin{itemize}
\item Uses a modified form of a subset of the XDR formal language.
\item Produces provable SPARK 2014.
\end{itemize}

\section{How It Works}

The user of CubedOS specifies through the XDR formal language subset defined in the RFC-4506
which modules will be able to encode and/or decode which kinds of CubedOS messages. Merc will
then generate provable SPARK 2014 for each module, based on the module and its capabilities.

\section{Competitive Analysis}

Most, if not all, primary competitors to CubedOS, such as those written in C (e.g. cFE [6]),
pass around Space Packets inter-modularly with no special internal encoding/decoding procedures
for separate ‘proprietary messages.’

Most primary competitors to the Merc tool, such as ONC RPC [2], Ice [3], Java RMI [4], and
WSDL [5], take a formal language (generally a data representation language) and package it up
client-side to send it over a network to a server that subsequently decomposes the code into
some other, executable code to perform an action server-side.

\begin{itemize}
\item \textbf{ONC RPC} is the closest in similarity to Merc in that it uses an XDR language
  extension (RPC language) client-side to initiate a RPC (Remote Procedure Call). The biggest
  difference is that ONC RPC was designed to be used two-way over an open network, whereas
  Merc simply generates provable SPARK 2014 files.

\item \textbf{Ice} is like ONC RPC except that it uses a proprietary language called Slice which
  is then compiled to a more widely used language, such as C, C\#, Java, JavaScript, or Python,
  etc., server-side after traversing a network as the payload of a common Internet transmissions
  protocol, such as TCP/IP or UDP.

\item \textbf{Java RMI} is like Ice, but only uses Java and the JVM for two-way data transfers.

\item \textbf{WSDL} is like Java RMI, but uses WSDL (Web Services Description Language).
\end{itemize}

\section{Use Cases}

Using the RFC-4506 as reference, the user of CubedOS specifies for a particular module what it
can handle in terms of encoding and decoding a subset of the pre-defined kinds of CubedOS
messages. The tool, Merc, is then invoked over the appropriate directory using a command-line
(CMD) syntax as illustrated in Appendix A. Merc then outputs provable SPARK 2014 which can be
manually placed into a project. The code is then statically tested.

\section{Behavior Characteristics}

Merc must be robust enough to handle all conceivable forms of human error and output a
message aimed at the elucidation of the user in each case of error, no matter how obscure or
intentional.

Merc must be simple enough, both in user learning and understanding of the tool and its
use—in functionality and use-restrictions—that a reasonable (and even novice) user could
successfully insert the encode and decode SPARK 2014 procedures and functions into their CubedOS
project with minor to no difficulty.

Merc takes as input a modified subset of the XDR language as an XDR file which handles
Integer, Unsigned Integer, Enumeration, Boolean, Fixed-Length Opaque Data, Variable-Length
Opaque Data, String, Fixed-Length Array, Variable-Length Array, Structure, and Typedef as
defined in RFC-4506 [1].

Merc shall modify the XDR specification to include ranges of types. E.g. typedef:

\begin{verbatim}
type-def:          
 "typedef" declaration ";"
\end{verbatim} 

shall become:

\begin{verbatim}
type-def:
"typedef" declaration  (“range” const “..” const )? ";"         
\end{verbatim}

Merc shall incorporate the ``message struct'' which is split by Merc into a SPARK enum, a
decode procedure, an encode function and a message “check” that verifies the message based on
its sender parameter and the type of message as proscribed in its message ID. E.g.:

\begin{verbatim}
message struct Example {
	Width_Type thing;
	};
\end{verbatim}

shall produce:

\begin{verbatim}
type Message_Type is (Example);
function Example_Encode 
	(sender: standard_with_all_messages; 
	thing: Width_Type; 
	priority: also_standard_with_all_messages);

in the SPARK *.ads file.
\end{verbatim}

\section{Representational Characteristics}

Merc shall be written in Scala and output provable SPARK 2014. As input, Merc accepts a
modified XDR file.

\section{Extrapolation}

Client-side Merc could very well insert an XDR file into the payload of a UDP or TCP/IP
protocol packet and be sent across a network (or even the Internet) to then produce an
executable outputted in SPARK 2014. This would require modification to the Scala used to write
the ANTLR generated compiler and would result in a product like those mentioned in Competitive
Analysis. This would also require intimate knowledge of the server to which the meta-packet is
sent, including having Merc set up server-side to accept an XDR file from the payload of a
meta-packet and decompose the file into a SPARK executable intended to be executed, typically,
on that same server. Then Merc server-side could reciprocate based on the instructions in the
SPARK executable.

\section{Examples}

<<Need all generally unique examples of modified XDR and it’s SPARK 2014 output not already
shown in Behavioral Characteristics. Need to dive into implementation first to know what needs
to be added to this section.>>

\section{Types Of CubedOS Messages}

<<null>>
