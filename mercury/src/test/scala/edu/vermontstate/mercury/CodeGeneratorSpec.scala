package edu.vermontstate.mercury

import java.io.{File, PrintStream}
import org.antlr.v4.runtime.*

class CodeGeneratorSpec extends UnitSpec {

  /**
    * Checks the two files to see if they are identical.
    *
    * @param generated The name of the file generated by Merc.
    * @param expected The name of the file containing the expected output.
    */
  def compareFiles(generated: String, expected: String): Unit = {
    val generatedText = io.Source.fromFile(generated)
    val expectedText = io.Source.fromFile(expected)

    val generatedLines = generatedText.getLines()
    val expectedLines = expectedText.getLines()

    for (generatedLine <- generatedLines) {
      val expectedLine = expectedLines.next()
      assert(
        generatedLine == expectedLine,
        s"Mismatched lines in $generated: Got: $generatedLine. Expected: $expectedLine")
    }

    generatedText.close()
    expectedText.close()
  }


  case class TestCase(
    fileName: String,
    expectedSpecification: String,
    expectedBody: String)

  "The CodeGenerator" should "process MXDR files into SPARK packages" in {
    val testCases = Array(
      TestCase("m0001.mxdr", "expected-m0001.ads", "expected-m0001.adb"),
      TestCase("m0002.mxdr", "expected-m0002.ads", "expected-m0002.adb"),
      TestCase("m0003.mxdr", "expected-m0003.ads", "expected-m0003.adb"),
      TestCase("m0004.mxdr", "expected-m0004.ads", "expected-m0004.adb"))

    for (testCase <- testCases) {
      val TestCase(sourceName, expectedSpecification, expectedBody) = testCase

      val folderName = "testData" + File.separator + "CodeGeneration" + File.separator
      val fullName = folderName + sourceName

      val codePointCharStream = CharStreams.fromFileName(fullName)
      val lexer  = new MXDRLexer(codePointCharStream)
      val tokens = new CommonTokenStream(lexer)
      val parser = new MXDRParser(tokens)
      val tree   = parser.specification()

      // Walk the tree created during the parse and analyze it for semantic errors.
      val symbolTable = new BasicSymbolTable
      val reporter    = new TestReporter(Array(), Array())
      val myTable     = new STPopulation(sourceName, symbolTable, reporter)
      myTable.visit(tree)
      val myAnalyzer  = new SemanticAnalyzer(sourceName, symbolTable, reporter)
      myAnalyzer.visit(tree)

      // Relative to the project root where this test is run.
      val templateFolder = "templates"

      val baseFileName = sourceName.substring(0, sourceName.lastIndexOf('.'))
      val baseFileNameLower = baseFileName.toLowerCase
      val fullSpecificationName = folderName + "cubedos-" + baseFileNameLower + "-api.ads"
      val fullBodyName = folderName + "cubedos-" + baseFileNameLower + "-api.adb"

      // Open the output files.
      val specificationFile = new PrintStream(fullSpecificationName)
      val bodyFile = new PrintStream(fullBodyName)

      // Do the code generation...
      val mySpecificationGenerator =
        new SpecificationGenerator(templateFolder, baseFileName, symbolTable, specificationFile, reporter)
      mySpecificationGenerator.visit(tree)

      val myBodyGenerator =
        new BodyGenerator(templateFolder, baseFileName, symbolTable, bodyFile, reporter)
      myBodyGenerator.visit(tree)

      // Close the output files.
      specificationFile.close()
      bodyFile.close()

      // Now compare the files to the expected results...
      compareFiles(fullSpecificationName, folderName + expectedSpecification)
      compareFiles(fullBodyName, folderName + expectedBody)
    }
  }
}
