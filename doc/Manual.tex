
\chapter{Manual}
\label{chapt:manual}

This chapter contains the user's manual for CubedOS. The intended audience of this chapter is
CubedOS application developers. Contributors to the CubedOS core and runtime library may also
find the information in this chapter useful.

We first discuss the details of module implementation and message passing, then the structure of an application.

\section{Module Organization}
\label{sec:module-organization}

In this section we describe the recommended structure of a basic CubedOS module. The CubedOS source
distribution includes a template module, with comments, that you can use as a starting point for
your own modules.

A module is a hierarchy of packages starting at the root package which uses the module name. All module functionality is contained in child packages. The root package can be used to hold module-wide declarations and functionality. In many cases the root package may not require a
body, although module-wide subprograms might usefully be declared in the root package.

CubedOS modules are intended to rely on an explicit message passing system for communication and should not publicly expose an API of functions directly impacting their state.

Convention for a module named |My_Module| encourages the use of three child packages:

\begin{itemize}
\item |My_Module.Messages| is a public child package containing the server task that loops
  infinitely reading the module mailbox and processing the messages it finds there. This loop
  drives the activity of the module, processing exactly one message at a time. No other task in
  the module, or indeed in the entire system, should read from the module's mailbox. The server task should receive a message in only one place in the program. This highly
  stylized structure is conceptually simple and easy to analyze.

  This package contains the public procedure |Init| which will be called on startup to register the module with the message system. This procedure contains multiple preconditions which are specified in the template module.

\item |My_Module.Internals| is a private child package that contains the bulk of the module's
  processing logic. The message loop is intended to be minimal; it calls into the |Internals|
  package as soon as it can. The code in this package is not accessible from outside the module
  and it can assume it is called by only one task (unless additional, internal tasks are created
  by the module developer). For simple modules, this package may be unnecessary.

\item |My_Module.API| is a public child package that specifies the module's interface. It contains helper functions for constructing
  and parsing module-specific messages, along with necessary module metadata which is used by the messaging system to promote safety. This file is automatically generated from an MXDR description of the module.
\end{itemize}

The module API is described in MXDR and then transpiled into the API package by Merc. Instructions on writing interfaces in MXDR and using Merc can be found in the Merc repository.

\section{Module Implementation}
\label{sec:module-implementation}

\subsection{Initialization}

The generated API file contains several components which are needed by the implementing module.

To use the messaging system, a module needs to hold a |Module_Mailbox| object. This object contains metadata describing the module's interface and is necessary in most messaging operations as proof of the module's identity. It should not be made accessible outside of the module in any way.

The object is typically a constant named |Mailbox| and is constructed by calling |Message_Manager.Make_Module_Mailbox|. The needed parameters for the call are values found in the genreated API file: |This_Module|, which refers to the module's ID, and |Mail_Target|, which contains the metadata.

At startup, all modules are registered with the messaging system. This is done sequentially by the main application thread by calling the |Init| procedure of each module. This procedure's only implementation requirement is to call |Message_Manager.Register_Module| and supply the |Mailbox| object. This registers the module with the message system, allowing it to proceed with the initialization process.

\subsection{Receiving Messages}

Messages sent to the module are stored in the |Message_Manager| and accessed via the |Message_Manager.Read_Next| function. Other functions for reading messages exist, but their use is for debugging purposes and they should not be by modules as they subvert the safety features of the messaging system.

The |Read_Next| procedure can only be used after the message system is fully initialized. The message manager provides a procedure that will block until this is done: |Message_Manager.Wait|. The call to |Wait| will communicate to SPARK that it is safe to read messages after it completes. Failing to wait before reading from the mailbox will produce a SPARK warning. |Wait| only needs to be called once before the message read loop.

To read a message from the module's mailbox, pass in the |Mailbox| object created during initialization. The function will block until a new message is available. It is guaranteed that the message read out is of a type explicitly specified as receivable in the module's interface, so implementations only need to handle those types of messages.

The message should be disbatched to a subprogram capable of dealing with it specifically.  The message type can be introspected by using the |Is_<message name>| functions found in the API package of the module which defined the message type.

For example, if your module receives |Tick_Reply| messages from the |CubedOS.Time_Server| module, then the function |Is_Tick_Reply| will exist in the |CubedOS.Time_Server.API| package. If your module receives a message type defined in its own specification, it will be found in its own API package.

Disbatched subprograms will likely need preconditions specifying that the message's payload is not null. This is guaranteed by the |Read_Next| procedure and is required by the decode functions. They will also need preconditions stating the type of the message they're being given to handle is of the correct type. This can be communicated to SPARK with a precondition expression like |Is_Tick_Reply(Input_Msg)|.

Once the message type is known, its contents can be decoded using the |Message_Name_Decode| function provided by its API file. Again, for a message defined in module |X|, the all relevant functionality for the message type will be found in the |X.API| package.

The decoder function takes in the message and provides several out parameters. In addition to the contents of the message, this will include a parameter |Decode_Status| which communicates if the message was decoded successfully. If the status indicates an unsuccessful decode, the decoded message content will be arbitrary and should be discarded.

Message types which have no content will not have a generated decoder function.

Messages use dynamic memory and need to be deallocated with the |CubedOS.Message_Types.Delete| procedure when you're done with them.

\subsection{Sending Messages}

Messages may not be sent until the message system has been initalized. The function |Message_Manager.Wait| will block until this time and must be called before any send operations will pass SPARK inspection.

The generated API files contain several |Send_Message_Type| procedures for each type of message. Each has slightly different parameters that satisfy different requirements. Some send procedures provide additional assurance about the message being sent, some provide feedback on message send operations.

All send procedures are non-blocking and require the sending module be specified by supplying the module's |Mailbox| object. They all also take a |Request_ID| number. This number is used to coordinate complex communications and can be read about earlier in this document. If no such coordination is needed, set it to 0.

When the destination module is known at compile time, use the safer variant of send. These send procedures take |Module_Metadata| and |Domain_Metadata| objects to identify the message destination. These objects can be found in the destination module's API package and the |Name_Resolver| file respectively. Providing these objects allows SPARK to verify certian aspects of the send operation are correct:

\begin{itemize}
\item The mailbox metadata is used to check that the receiving module has declared support for the type of message being sent. This allows SPARK to detect statically if the message will not be successfully received by the destination module and warn you about it. This could reveal an error in the interface definition for a module, or alert you that you sent the message to the wrong module, saving time spent debugging later.

\item The domain metadata is used to check that the destination domain contains the destination module. Again, if you forgot to declare a module as part of a domain, or sent something to the wrong domain by mistake, SPARK will notify you.
\end{itemize}

Unfortunately, the receiver of a send operation isn't always known at compile time. In such cases, the less safe variant of the send procedure must be used. It takes the address of the destination module, a (|Domain_ID|, |Module_ID|) pair. If a send operation is incorrect, the message will be discarded at runtime by the message system.

There are also variants of send which do and don't include a result |Status| of the send operation. Procedures do return a status provide an additional out parameter notifying the sender immediately if the message was successfully deposited in the destination mailbox. If the message type is not acceptable by the destination, it is possible that the status will be successful but that the message will be discarded before it is read. If the destination domain isn't the current one, the message's successful transfer can't be known and the status result will reflect this.


\section{Transport Modules}

TODO

\section{Application Structure}

A CubedOS application consists of one or more domains each with one or more module. We have already discussed the creation of modules which are intended to be reusable. In this section we will describe the structure of a CubedOS application and its components.

All modules involved in an application must be assigned a module ID. This number uniquely identifies a module type, not a module instance. Multiple instances of the same module share the same module ID. It is necessary to assign an ID to a module for message passing to work.

Module ID assignments for the entire application are stored in a user-defined |Name_Resolver| package. The package must have this name. For each module, a constant is defined with the module's name and an ID.

\begin{verbatim}
Log_Server               : constant Module_ID_Type := 1;
Publish_Subscribe_Server : constant Module_ID_Type := 2;
Time_Server              : constant Module_ID_Type := 3;
File_Server              : constant Module_ID_Type := 4;
\end{verbatim}

In the same package, we then describe each domain in the application by creating a |Domain_Metadata| object. Many applications only have one domain.

\begin{verbatim}
Domain_Name : aliased constant Domain_Metadata := (4, 1, (Log_Server,
                                                    Publish_Subscribe_Server,
                                                    Time_Server,
                                                    File_Server));
\end{verbatim}

The object specifies the number of modules in the domain, the domain's ID, and what modules are present in the domain.

Each domain in the application must have its own directory containing at least these components:

\begin{itemize}
\item |message_manager.ads| contains the package |Message_Manager| which is an instantiation of the |CubedOS.Generic_Message_Manager| package. This object is the message system for the domain and is referenced by all the modules in the domain. It is instantiated using one of the domain constants declared in |Name_Resolver|.

\begin{verbatim}
package Message_Manager is
  new CubedOS.Generic_Message_Manager
    (Domain => Name_Resolver.Domain_Name,
     Debugger => CubedOS.Message_Debuggers.Null_Message_Debugger_Object);
\end{verbatim}

It's possible to instantiate the message manager with debugger object which will expose useful information about messages at runtime. CubedOS provides two debugger implementations in |CubedOS.Message_Debuggers| and it is possible to create your own by inheriting from the |Message_Debugger| interface.

\item |domain_config.adb| implements the |Domain_Config| package. This package is used by the |Message_Manager| to handle transport modules and inter-domain communication.

\item |main.adb| is the program entry point. It "with"s every module included by the domain. The program calls every module's |Module_Name.Messages.Init| procedure.

\begin{verbatim}
with CubedOS.File_Server.Messages;
with CubedOS.Log_Server.Messages;
with CubedOS.Publish_Subscribe_Server.Messages;
with CubedOS.Time_Server.Messages;
-- with Message_Manager;

procedure Main is
begin
   CubedOS.Interpreter.Messages.Init;
   CubedOS.Log_Server.Messages.Init;
   CubedOS.Publish_Subscribe_Server.Messages.Init;
   CubedOS.File_Server.Messages.Init;
   CubedOS.Time_Server.Messages.Init;

   -- Message_Manager.Skip_Mailbox_Initialization;
end Main;
\end{verbatim}

Calling |Init| on every module in the domain will complete the |Message_Manager|'s initalization and allow message sending begin in the application. This ensures that every module is present in the system and ready to handle messages.

During development if not all modules are available or you want to do testing on a subset of modules, it is possible to skip the inialization procedure by calling |Message_Manager.Skip_Mailbox_Initalization|. This is dangerous and should only be done during development.
\end{itemize}

Examples of these files can be found in the CubedOS source repository.

