
\chapter{Samples}
\label{chapt:samples}

This chapter contains documentation about the sample programs provided with Cubed\-OS. These
programs illustrate various aspects of using CubedOS in the real world that might not be
covered by the more formal documenation presented so far. New users of CubedOS are encouraged to
study, build, execute, and modify the sample programs as a way of learning about the system and
how it can be used.

\section{Ping Pong Sample}
\label{sec:ping-pong-sample}

\todo{Finish Me!}

\section{STM32F4 Sample}
\label{sec:stm32f4-sample}

This section describes the architecture of the the STM32F4 sample that can be found in a folder
of the same name in the CubedOS repository. This sample makes use of a simple evaluation board
from STMicroelectronics. The README file in the STM32F4 folder gives specifics about the board
and about how to set up the build environment.

The sample program is simple in effect, but written in a way as to illustrate some of CubedOS's
structure and features. The program flashes the LEDs on the board in a rotating sequence, from
green to orange to red to blue. The program also watches the user button on the board (the blue
button). When pressed, the speed of the flashing increases in steps, from low to medium to high
and then back to low. The program has no other features.

This program illustrates several things.
\begin{itemize}
\item Using CubedOS with a non-native CPU. The sample was developed on a Linux desktop system
  running a 64~bit Intel processor. The project, however, is configured to generate code for an
  ARM Cortex M4 CPU. This affects not only the compiler being used, but also the \SPARK\
  configuration used to analyze the code.
\item Using an embedded platform. The sample makes use of AdaCore's small footprint Ravenscar
  runtime for the STM32F4 along with a few files provided by AdaCore for accessing the low level
  hardware on the board. It does not make use of any conventional operating system.
\item Using CubedOS modules as drivers for onboard hardware. Although this simple application
  could be more easily programmed without creating driver modules, for purposes of illustration
  it includes two driver modules for the hardware used: an LED driver and a button driver.
\item Using a CubedOS ``controller'' module as the main module of the program. The controller
  module responds to events generated on the board by sending messages to other modules as
  appropriate. The controller thus serves as the main part of the application and encodes the
  high level application logic. The Ada main procedure contains no application functionality at
  all. This is a typical for CubedOS applications.
\item Using the publish/subscribe server, a core CubedOS module, for decoupling event sources
  (as generated by the button driver) to even sinks (the controller module). This allows the
  driver modules to be reusable in other applications for this platform. Specifically the button
  driver does not directly interact with the application-specific controller. It could be
  dropped into another application, along with the core publish/subscribe server module, without
  modification.
\end{itemize}

In the subsections that follow more details are given about each of these points.

\subsection{Non-Native CPU}

The STM32F4 sample uses an ARM Cortex M4 processor. This entails installing the necessary Ada
cross compiler from AdaCore. The project file specifies the tool chain to be used. The other
important aspect of using a non-native CPU is configuring \SPARK\ to know about the target
platform attributes. Since the sizes and ranges of the primitive types are often different on
the embedded platform than on the native platform, the sizes and ranges of the Ada base types
are also often different. This affects when computations might overflow. Consider, for example,
this simple case:

\begin{lstlisting}
declare
   type Some_Type is range 0 .. 20_000;
   A, B, C : Some_Type;
begin
   -- etc...
   A := (B + C) / 2;
end;
\end{lstlisting}

On a system where the base type of |Some_Type| has 32~bits, there is no possibility of overflow
when computing |(B + C)/2| since, at most, |B + C| would be 40,000. However, if a 16~bit base
type is used, as might be the case on a small microcontroller platform, |B + C| might go outside
the range of 16~bit signed integers, and an overflow would be possible. The \SPARK\ tools know
what base types are used by the Ada compiler, but that depends on the platform being targetted
by that compiler. It is thus essential to inform the \SPARK\ tools about the target platform so
that the proofs are relevant and correct for the target context. By default the \SPARK\ tools
will assume the native platform's properties, which might not be appropriate when cross
compiling.

\todo{Finish Me!}

\section{LineRider Sample}
\label{sec:linerider-sample}

\todo{Finish Me!}

\section{Networking Sample}
\label{sec:linerider-sample}

The Networking sample demonstrates a multi-domain application.

The sample contains two projects |domaina.gpr| and |domainb.gpr|. Domain A contains a |Ping_Client| module and Domain B a |Ping_Server|. The domains communicate using the CubedOS UDP transport module. Start domain B first and then A and you should see the ping result in the console output of both.
